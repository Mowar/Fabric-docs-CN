# Ledger - 账本

## What is a Ledger? - 什么是账本？

一个账本包含了对于一个业务的当前的 state，就像是一个包含所有交易的分类账本。在大概 1000 年前，就有最早的欧洲和中国的账本，在 4000 年前，苏美尔人拥有 [石头账本](http://www.sciencephoto.com/media/686227/view/accounting-ledger-sumerian-cuneiform) -- 但是让我们从一个更现代化的例子开始！

你可能已经习惯了每个月都去查看一下你的银行账户。对于你来说最重要的应该是可用的余额 -- 那是你在当时可以花费的部分。如果你想看看你的余额是如何产生出来的，那么你可以查看收入和支出的交易记录。这是现实生活中的一个账本的例子 -- 一个 state (你的银行余额)，和决定了余额的一系列的有序的交易 (收入和支出)。Hyperledger Fabric 同样是基于这两个问题而产生的 -- 用来展示一系列账本的 states 的当前值，并且记录决定了这些 states 的交易记录。

让我们来详细看一下 Hyperledger Fabric 的账本结构吧！

## A Blockchain Ledger - 一个区块链账本

一个区块链账本包含两部分，但是是两个相关的部分 -- 一个 world state 和一个区块链。

首先，这里存在一个 **world state** -- 存储了一系列账本 states 的 **当前值** 的数据库。World state 使程序能够轻松地获得这些 states 的当前的值，而不是要让程序根据之前所有的交易记录来自己计算得出。账本的 states 默认是以 **键-值** 对的形式来表示的，稍后我们会看到 Hyperledger Fabric 对于这个提供了一些灵活性。Wrold state 可以被频繁地更改，因为 states 可以被创建、更新和删除。

其次，这里还存在一个 **区块链** -- 一个记录了确定这个 world state 的所有变更的交易 log。交易被整理在了区块里边并且被附加在了区块链上 -- 能够使你理解产生当前的 world state 的变更历史。区块链的数据结构相比 world state 有很大的不同，因为一旦写入，它就不能够被修改了。这是一个 **不可变** 的区块的序列，每个区块都包含了一系列有序的交易。

![ledger.ledger](./ledger.diagram.1.png)

*这个视觉词汇实际上表述了下边这样的事实：账本 L 是由区块链 B 和 World State W 组成的。区块链 B 决定了 World State W。同时它也表示了：World State 是由区块链 B 来推导出的。*

在一个 Hyperledger Fabric 网络中存在一个 **逻辑** 账本。在现实世界中，这个网络维护了一个账本的多个副本 -- 他们彼此通过一个称为 **共识** 的流程保持一致。**分布式账本技术** (**DLT**) 这个词经常会关联到这种类型的账本上 -- 一个逻辑上是单独的，但是有很多相同的副本分布式地存储在一个网络中。

现在让我们来详细看一下 world state 和区块链数据结构。

## World State

World state 代表了所有账本 states 的当前值。这是非常有用的，因为程序经常需要知道一个账本 state 当前的值并且它总是能够被轻松的得到。你不需要去查看整个区块链来计算任何账本 state 的当前的值 -- 你可以直接从 world state 来得到它。

![ledger.worldstate](./ledger.diagram.3.png)

*这个视觉词汇描述了下边这样的事实：这里有一个带有 key=CAR1 和 value=Audi 的账本 state。还有一个 key=CAR2 和一个更复杂的值 {model:BMW, color=red, owner=Jane} 的一个账本 state。两个 states 都是在版本 0。*

账本 state 被用来记录通过区块链来被共享的应用程序信息。上边的例子展示了关于两辆汽车，CAR1 和 CAR2 的账本 states。能够看到 states 包含了一个键和一个值。你的应用程序通过调用 chaincode，它可以通过简单的 APIs 来访问 states -- 他们使用一个 state 键来 **获取**，**添加** 和 **删除** states。注意到一个 state 的值可以是非常简单 (Audi...) 或者是复杂的 (type:BMW...)。

物理上，world state 是作为一个数据被实现的。这很有道理因为一个数据库提供了一套丰富的操作来有效的存储和返回 states。之后我们会看到 Hyperledger Fabric 能够针对不同类型的 state 值以及应用程序所需的访问模式，比如需要复杂的查询来配置使用不同的 world state 数据库。

交易记录了关于 world state 的变更，并且像你预期的那样，交易具有一个生命周期。他们由应用程序创建，最终会以提交到账本区块链结束。整个生命周期在 [这里](../txflow.html) 有详细描述；但是 Hyperledger Fabric 的核心设计点是只有被一系列 **背书组织** **签名** 的交易才能够对 world state 产生更新。如果一笔交易没有被有效的背书节点签名的话，它不会通过有效性检查，也不会对 world state 产生更新。

你也会注意到一个 state 具有一个版本编号，并且在上边的图表中，states CAR1 和 CAR2 都处在他们的起始版本，0。一个 state 的版本号在每次 state 变更的时候是自增长的。它也会在每次 state 被更新的时候被检查 -- 来确保它跟交易产生的时候的版本号是匹配的。这个检查确保了 world state **从相同的期望值变更到相同的期望值**，跟交易被创建的时候是一致的。

最终，当一个账本第一次被创建的时候，world state 是空的。因为任何代表一个有效的对于 world state 的变动的交易都会被记录到区块链中，这意味着 world state 可以在任何时间从区块链上被重新生成。这是非常方便的 -- 比如，当一个 peer 节点被创建的时候，world state 会被自动的生成。如果一个 peer 节点非正常的停掉了，当 peer 重启的时候，在交易被接受前，world state 能够被重新生成。

## Blockchain - 区块链

现在，让我们把注意力从 world state 转移到区块链上来。

区块链是一个交易 log，结构是内部连接的区块的形式，每个区块包含了许多交易的顺序，每笔交易代表了对于 world state 的查询或者变更。关于交易是如何被排序的详细机制在 [这里](../peers/peers.html#peers-and-orderers) 被讨论 -- 重要的是区块的顺序，和区块内部的交易的顺序，这是在区块第一次被创建的时候制定的。

每个区块的头包含了区块的交易的哈希值，也包括了前一个区块头的哈希值的副本。通过这种方式，账本上的所有交易都是有序的并且通过加密的形式连接在了一起。这种哈希和连接使账本数据非常安全。即使一个节点拥有的账本被改动了，这不会影响其他的具有 “正确的” 区块链的节点，因为账本是被分发到一个网络的不同的独立节点的。

物理上，区块链通常是以文件的形式实现的，对比于使用数据库的 world state。这是一个有意义的设计选择，因为区块链数据结构只会涉及到非常少的一系列简单操作。向区块链的尾部附加新的区块是主要的操作，查询对于当前来说是一个相对不经常做的一项操作。

让我们更详细的看下一个区块链的结构。

![ledger.blockchain](./ledger.diagram.2.png)

*这个视觉词汇描述了下边这样的事实：区块链 B 包含了区块 B0, B1, B2, B3。B0 是区块链中的第一个区块，创世区块*

在上边的图表中，我们能够看到 **区块** B2 有一个 **区块数据** D2，它包含了所有的交易：T5，T6，T7。

最重要的是，B2 有一个 **区块头** H2，它包含了一个在 D2 中的所有交易的经过加密的 **哈希值**，还有从前一个区块 B1 的同等的哈希值。通过这种方式，这些区块变成了无法拆分并且无法变更的彼此相互关联，这正是 **区块链** 这个词所表达的意义！

最终，就像你在图表中看到的，在区块链中的第一个区块被称为 **创世区块**。它是账本的起点，尽管它没有包含任何的用户交易。但是，它包含了一个配置交易，其中包括这个网络 channel (没有显示出来) 的初始 stste。我们会在讨论区块链网络和 [channels](../channels.html) 的时候更详细地讨论创世区块。

## Blocks - 区块

让我们来更进一步地研究一下一个区块的结构。它包含三个部分

* **Block Header** - **区块头**

  这个部分包含三个字段，是当一个区块被创建的时候写入的。

  * **区块编号**: 一个从 0  开始 (创世区块) 的数字，对于每一个附加到区块链上的新的区块，它的编号会增加1。

  * **当前区块的哈希值**: 在当前区块中包含的所有交易的哈希值。

  * **前一区块的哈希值**: 在区块链中前一个区块的哈希值的副本。

  ![ledger.blocks](./ledger.diagram.4.png)

  *这个视觉词汇描述了下边这样的事实：区块 B2 的区块头 H2 包含了区块编号 2，当前区块数据 D2 的哈希值 CH2，和从前一个区块的哈希值 PH1 的副本，区块编号 1。*

* **Block Data** - **区块数据**

  这部分包含了一个有序排列的交易列表。它是在区块被创建的时候写入的。这些交易具有一个丰富但是很直接的结构，我们会在 [后边](#Transactions) 描述。

* **Block Metadata** - **区块 Metadata**

  这个部分包含了区块被写入的时间，还有证书，公钥以及区块写入者的签名。接下来，区块的提交者也会为每一笔交易添加一个有效/无效的标记，但是这个信息是不会包含进哈希值的，因为它是在区块已经被写入的时候产生的。

## Transactions - 交易

就像我们看到的，一笔交易记录了对于 world state 的变更。让我们来详细看一下 **区块数据** 的结构，这些数据指的是包含在一个区块中的交易。

![ledger.transaction](./ledger.diagram.5.png)

*这个视觉词汇描述了下边这样的事实：区块 B1 的区块数据 D1 中的交易 T4 包括了交易头 H4，一个交易签名 S4，一个交易的提案 P4，一个交易的回应，和一个背书的列表, E4。*

在上边的例子中，我们能够看到以下的字段：

* **Header** - **头**

  这部分由 H4 表示，记录了关于交易的一些基本的 metadata -- 比如，相关的 chaincode 的名字以及它的版本。

* **Signature** - **签名**

  这部分由 S4 表示，包含了一个由客户端应用程序创建的经过加密的签名。这个字段被用来检查交易的详细内容没有被篡改过，因为这个签名需要应用程序的私钥来生成。

* **Proposal** - **提案**

  这部分由 P4 表示，包含了对于 chaincode 的一个应用程序提供过的输入参数，这个 chaincode 创建了这个对账本的更新。当 chaincode 执行的时候，这个提案提供了一套输入参数，这些参数同当前的 world state 一起决定了新的 world state。

* **Response** - **回应**

  这部分由 R4 表示，记录了 world state 的之前和之后的值，作为 **读写集** (RW-set)。它是一个 chaincode 的输出，并且如果交易被正确地验证过了的话，它会被应用到账本上以更新 world state。

* **Endorsements** - **背书**

  就像 E4 显示的那样，这是一个来自于每个所需组织的签过名的交易回应的列表，这能够有效的满足背书策略。你会注意到，在交易中只包含一个交易回应，但是会有多个背书。这是因为每个背书有效地包含了它的组织的指定的交易回应 -- 这意味着不需要包含任何的没有满足有效的背书的交易回应因为它会被作为无效的交易被拒绝，并且不会更新 world state。

这就证明了交易的主要字段 -- 还有一些其他的，但是这些是你需要理解的以对于账本数据结构有很深的理解的基础知识。

## World State database options - World state 数据库选项

World state 物理上是以一个数据库的形式实现的，提供了简单有效的对于账本 states 的存储及获取。就像我们看到的，账本 states 可以有简单或者复杂的值，为了适应这个，world state 数据库实现很多样，允许这些值能够被有效的实现。当前对于 world state 数据库的选项包括 LevelDB 和 CouchDB。

默认的是 LevelDB，这对于账本 states 是简单的键-值对的情况是很适用的。一个 LevelDB 数据库会紧密地跟一个网路节点关联 -- 它会被嵌入到以相同的操作系统进程中。

CouchDB 对于账本 states 的结构是 JSON 文档的形式的时候比较适用，因为 CouchDB 支持富查询以及对在业务交易中经常发现的富数据类型。实现的角度上讲，CouchDB 运行在一个分开的操作系统进程中，但是这在一个网络节点和一个 CouchDB 实例之间还是有一个 1:1 的关系。所有这些都能在 chaincode 中看到。浏览 [CouchDB 作为 StateDatabase](../couchdb_as_state_database.html) 了解更详细内容。

在 LevelDB 和 CouchDB 中，我们能够看到 Hyperledger Fabric 的一个重要的特征 -- 它是 *可插拔* 的。World state 数据库可以是一个关系型数据存储，或者是一个 graph 存储，或者是一个临时的数据库。这对于不同的账本 states 的类型进行有效的访问提供了很大的灵活性，允许 Hyperledger Fabric 解决不同类型的问题。

## Example Ledger: fabcar - 样例账本: fabcar

因为我们要以这个话题来结束账本的介绍，让我们来看一个样例账本。如果你运行了 [fabcar sample application](../write_first_app.html)，那么你就已经创建了这个账本。

Fabcar 样例应用创建了一套 10 辆车，有不同的颜色，制造商，型号和拥有者。下边是在前四辆车被创建之后账本的样子。

![ledger.transaction](./ledger.diagram.6.png)

*这个视觉词汇描述了下边这样的事实：账本 L 包含了一个 world state W 和一个区块链 B。W 包含了四个 states，state 包含键：CAR1, CAR2, CAR3 and CAR4*。B 包含两个区块，0 和 1。区块 1 包含了四笔交易：T1, T2, T3, T4.*

我们能够看到账本的 world state 包含了对应于 CAR0, CAR1, CAR2 and CAR3 的 world states。CAR0 具有一个表述这是一个绿色的 Toyota Prius，由 Tomoko 拥有的值，我们还能看到对于其他车的类似的 states。并且，我们能够看到所有的 car states 都在版本编号 0，说明这是他们的开始版本编号 -- 他们在被创建之后还没有被更新过。

我们还能看到这个账本区块链包含两个区块。区块 0 是创世区块，尽管他没有包含任何有关车的交易。区块 1 包含了交易 T1, T2, T3, T4 这些是对应于在 world state 中的创建对于 CAR0 到 CAR3 的初始 states 交易。我们能够看到区块 1 是连接到 区块 0 的。

我们没有显示区块或者交易中的其他字段，尤其是头和哈希值。如果你对这些感兴趣的话，你会在文档的其他部分找到专有的参考话题。它会给你一个整体的可工作的例子，包含所有的区块和他的交易的详细内容 -- 但是目前来说，你已经对于一个 Hyperledger Fabric 账本有了很好的概念上的理解了。做的很棒！

## More information - 更多信息

查看 [交易流](../txflow.html),
[读写集语义学](../readwrite.html) 和
[CouchDB 作为 StateDatabase](../couchdb_as_state_database.html) 话题来深入了解交易流程，并发控制和 world state 数据库。

<!--- Licensed under Creative Commons Attribution 4.0 International License
https://creativecommons.org/licenses/by/4.0/ -->
